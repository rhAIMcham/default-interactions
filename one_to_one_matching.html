<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>One to One Matching</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:ital,wght@0,100..700;1,100..700&display=swap" rel="stylesheet">
    <style>
    :root {
    --AIMblue: #4353A3;
    --darkBlue: #38416D;
    --teal: #5DC8B9;
    --cream: #F1EEDE;
    --grey: #e7e9ec;
    --rust: #AF4510;
    --navy: #12195C;
    --white: #ffffff;
    --lightBlue: #AEBAE4;
    }
    * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    }

    body {
    font-family: "IBM Plex Sans", sans-serif;
    min-height: 90vh;
    padding: 30px 20px;
    background: #f5f6f8;
    }

    .container {
    max-width: 900px;
    margin: 0 auto;
    }

    h1 {
    color: var(--darkBlue);
    text-align: center;
    margin-bottom: 30px;
    font-size: 2em;
    font-weight: 600;
    }

    .matching-area {
    display: flex;
    gap: 40px;
    justify-content: center;
    align-items: flex-start;
    margin-bottom: 40px;
    }

    .column {
    background: white;
    border-radius: 12px;
    padding: 24px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    flex: 1;
    min-width: 300px;
    }

    .column-header {
    font-weight: 600;
    font-size: 1.3em;
    color: var(--darkBlue);
    margin-bottom: 20px;
    text-align: center;
    padding-bottom: 12px;
    border-bottom: 3px solid var(--lightBlue);
    }

    .items-list {
    display: flex;
    flex-direction: column;
    gap: 12px;
    }

    .static-item {
    background: linear-gradient(135deg, var(--AIMblue) 0%, var(--darkBlue) 100%);
    color: white;
    padding: 16px 20px;
    border-radius: 8px;
    font-size: 1em;
    font-weight: 500;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .draggable-item {
    background: white;
    border: 2px solid var(--lightBlue);
    border-radius: 8px;
    padding: 16px 20px;
    cursor: move;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    transition: transform 0.3s ease, box-shadow 0.2s ease, border-color 0.2s ease, background-color 0.2s ease;
    font-size: 1em;
    position: relative;
    }

    .draggable-item:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.15);
    border-color: var(--AIMblue);
    }

    .draggable-item.dragging {
    opacity: 0.6;
    transform: scale(1.05) rotate(3deg);
    box-shadow: 0 8px 16px rgba(0,0,0,0.3);
    z-index: 100;
    border-color: var(--AIMblue);
    border-width: 3px;
    }

    .draggable-item.drag-over {
    border-color: var(--teal);
    background: #f0fffe;
    border-style: dashed;
    border-width: 3px;
    transform: scale(1.02);
    box-shadow: 0 0 0 3px rgba(93, 200, 185, 0.3);
    }

    .draggable-item:focus {
    outline: 3px solid var(--AIMblue);
    outline-offset: 2px;
    }

    .draggable-item.keyboard-grabbed {
    border-color: var(--AIMblue);
    border-width: 3px;
    background: #e8f4ff;
    box-shadow: 0 4px 12px rgba(67, 83, 163, 0.3);
    }

    .draggable-item.swapping {
    animation: swap 0.4s ease-in-out;
    }

    @keyframes swap {
        0% {
            transform: translateX(-50);
        }
        50% {
            transform: translateX(-20px) scale(0.95);
            background-color: var(--lightBlue);
        }
        100% {
            transform: translateX(0);
        }
    }

    .draggable-item.correct {
    border-color: #28a745;
    background: linear-gradient(135deg, #d4edda 0%, #ffffff 100%);
    /* animation: correctFlash 0.5s ease-in-out; */
    }

    .draggable-item.incorrect {
    border-color: #dc3545;
    background: linear-gradient(135deg, #f8d7da 0%, #ffffff 100%);
    /* animation: incorrectShake 0.5s ease-in-out; */
    }

    @keyframes correctFlash {
        0%, 100% {
            transform: scale(1);
        }
        50% {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(40, 167, 69, 0.5);
        }
    }
/* 
    @keyframes incorrectShake {
        0%, 100% {
            transform: translateX(0);
        }
        25% {
            transform: translateX(-10px);
        }
        75% {
            transform: translateX(10px);
        }
    } */

    #submitBtn {
    display: block;
    margin: 30px auto;
    padding: 14px 50px;
    background: var(--AIMblue);
    color: white;
    border: none;
    border-radius: 8px;
    font-size: 1.2em;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }

    #submitBtn:hover {
    background: var(--darkBlue);
    transform: translateY(-2px);
    box-shadow: 0 6px 12px rgba(0,0,0,0.15);
    }

    .modal-overlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.6);
    justify-content: center;
    align-items: center;
    z-index: 1000;
    }

    .modal-overlay.show {
    display: flex;
    }

    .modal-content {
    background: white;
    padding: 40px;
    border-radius: 12px;
    max-width: 600px;
    width: 90%;
    box-shadow: 0 10px 40px rgba(0,0,0,0.3);
    }

    .modal-content h2 {
    color: var(--darkBlue);
    margin-bottom: 20px;
    font-size: 1.8em;
    }

    .modal-content p {
    font-size: 1.1em;
    line-height: 1.6;
    color: #5e6c84;
    margin-bottom: 10px;
    }

    .modal-close-btn {
    margin-top: 20px;
    padding: 12px 30px;
    background: var(--AIMblue);
    color: white;
    border: none;
    border-radius: 6px;
    font-size: 1em;
    cursor: pointer;
    transition: background 0.2s;
    }

    .modal-close-btn:hover {
    background: var(--darkBlue);
    }

    .instructions {
    text-align: center;
    margin-bottom: 30px;
    padding: 20px;
    background: white;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .instructions p {
    color: #5e6c84;
    font-size: 1.1em;
    }

    @media (max-width: 768px) {
        .matching-area {
            flex-direction: column;
        }
    }

    .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border-width: 0;
    }

    /* Reduced motion support */
    @media (prefers-reduced-motion: reduce) {
        .draggable-item,
        .draggable-item.dragging,
        .draggable-item.drag-over,
        .draggable-item.swapping,
        .draggable-item.correct,
        .draggable-item.incorrect {
            animation: none;
            transition: none;
        }
        
        .draggable-item.drag-over {
            border-width: 4px;
        }
    }
  </style>
</head>
<body>
    <div class="container">
        <h1>Match the Items</h1>
        
        <div class="instructions">
            <p>Reorder the list on the right to correctly match the list on the left. Drag and drop the elements or use keyboard controls: <strong>Space</strong> to grab/drop, <strong>Arrow keys</strong> to move</p>
        </div>

        <div class="matching-area">
            <!-- Static Answer Column -->
            <div class="column">
                <div class="column-header">Match To</div>
                <div class="items-list">
                    <div class="static-item">Item A</div>
                    <div class="static-item">Item B</div>
                    <div class="static-item">Item C</div>
                    <div class="static-item">Item D</div>
                    <div class="static-item">Item E</div>
                    <div class="static-item">Item F</div>
                </div>
            </div>

            <!-- Draggable/Reorderable Column -->
            <div class="column">
                <div class="column-header">Your Answers</div>
                <div class="items-list" id="answerList">
                    <div class="draggable-item" draggable="true" data-id="item3" role="button" aria-grabbed="false" tabindex="0">Match C</div>
                    <div class="draggable-item" draggable="true" data-id="item1" role="button" aria-grabbed="false" tabindex="0">Match A</div>
                    <div class="draggable-item" draggable="true" data-id="item5" role="button" aria-grabbed="false" tabindex="0">Match E</div>
                    <div class="draggable-item" draggable="true" data-id="item2" role="button" aria-grabbed="false" tabindex="0">Match B</div>
                    <div class="draggable-item" draggable="true" data-id="item6" role="button" aria-grabbed="false" tabindex="0">Match F</div>
                    <div class="draggable-item" draggable="true" data-id="item4" role="button" aria-grabbed="false" tabindex="0">Match D</div>
                </div>
            </div>
        </div>

        <button onclick="checkAnswers()" id="submitBtn">Submit Answers</button>
    </div>

    <div class="modal-overlay" id="resultsModal">
        <div class="modal-content">
            <h2 id="modalTitle"></h2>
            <div id="modalMessage"></div>
            <button class="modal-close-btn" onclick="closeModal()">Close</button>
        </div>
    </div>

    <!-- Screen reader announcements -->
    <div id="sr-announcement" class="sr-only" role="status" aria-live="polite" aria-atomic="true"></div>

<script>
let draggedItem = null;
let keyboardGrabbedItem = null;

// Correct answer order
const correctOrder = ['item1', 'item2', 'item3', 'item4', 'item5', 'item6'];

function initDragAndDrop() {
    const items = document.querySelectorAll('.draggable-item');
    
    items.forEach(item => {
        item.addEventListener('dragstart', handleDragStart);
        item.addEventListener('dragend', handleDragEnd);
        item.addEventListener('dragover', handleDragOver);
        item.addEventListener('drop', handleDrop);
        item.addEventListener('dragenter', handleDragEnter);
        item.addEventListener('dragleave', handleDragLeave);
        item.addEventListener('keydown', handleKeyDown);
    });
}

function handleKeyDown(e) {
    const items = [...document.querySelectorAll('.draggable-item')];
    const currentIndex = items.indexOf(e.target);
    
    // Space or Enter to grab/drop
    if (e.key === ' ' || e.key === 'Enter') {
        e.preventDefault();
        
        if (!keyboardGrabbedItem) {
            // Grab the item
            keyboardGrabbedItem = e.target;
            keyboardGrabbedItem.classList.add('keyboard-grabbed');
            keyboardGrabbedItem.setAttribute('aria-grabbed', 'true');
            announceToScreenReader(`Grabbed ${e.target.textContent.trim()}. Use arrow keys to move, space to drop.`);
        } else if (keyboardGrabbedItem === e.target) {
            // Drop the item in current position
            keyboardGrabbedItem.classList.remove('keyboard-grabbed');
            keyboardGrabbedItem.setAttribute('aria-grabbed', 'false');
            const newPosition = items.indexOf(keyboardGrabbedItem) + 1;
            announceToScreenReader(`Dropped ${keyboardGrabbedItem.textContent.trim()} at position ${newPosition}`);
            keyboardGrabbedItem = null;
            
            // Clear any feedback from previous check
            items.forEach(item => {
                item.classList.remove('correct', 'incorrect');
            });
        }
    }
    
    // Arrow keys to move grabbed item
    if (keyboardGrabbedItem && (e.key === 'ArrowUp' || e.key === 'ArrowDown')) {
        e.preventDefault();
        
        const currentPos = items.indexOf(keyboardGrabbedItem);
        let newPos;
        
        if (e.key === 'ArrowUp' && currentPos > 0) {
            newPos = currentPos - 1;
        } else if (e.key === 'ArrowDown' && currentPos < items.length - 1) {
            newPos = currentPos + 1;
        } else {
            return; // Can't move further
        }
        
        // Animate the swap
        const targetItem = items[newPos];
        targetItem.classList.add('swapping');
        
        // Perform the swap
        const answerList = document.getElementById('answerList');
        if (e.key === 'ArrowUp') {
            answerList.insertBefore(keyboardGrabbedItem, targetItem);
        } else {
            answerList.insertBefore(keyboardGrabbedItem, targetItem.nextSibling);
        }
        
        // Keep focus on the grabbed item
        keyboardGrabbedItem.focus();
        
        // Announce position
        const newPosition = [...document.querySelectorAll('.draggable-item')].indexOf(keyboardGrabbedItem) + 1;
        announceToScreenReader(`Moved to position ${newPosition}`);
        
        // Remove animation
        setTimeout(() => {
            targetItem.classList.remove('swapping');
        }, 400);
        
        // Clear any feedback from previous check
        items.forEach(item => {
            item.classList.remove('correct', 'incorrect');
        });
    }
    
    // Escape to cancel
    if (e.key === 'Escape' && keyboardGrabbedItem) {
        keyboardGrabbedItem.classList.remove('keyboard-grabbed');
        keyboardGrabbedItem.setAttribute('aria-grabbed', 'false');
        announceToScreenReader('Cancelled grab');
        keyboardGrabbedItem = null;
    }
    
    // Tab navigation - just clear feedback colors
    if (e.key === 'Tab') {
        items.forEach(item => {
            item.classList.remove('correct', 'incorrect');
        });
    }
}

function handleDragStart(e) {
    draggedItem = this;
    this.classList.add('dragging');
    this.setAttribute('aria-grabbed', 'true');
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/html', this.innerHTML);
    
    // Announce to screen readers
    announceToScreenReader(`Picked up ${this.textContent.trim()}`);
}

function handleDragEnd(e) {
    this.classList.remove('dragging');
    this.setAttribute('aria-grabbed', 'false');
    
    // Remove drag-over class from all items
    document.querySelectorAll('.draggable-item').forEach(item => {
        item.classList.remove('drag-over');
    });
}

function handleDragOver(e) {
    if (e.preventDefault) {
        e.preventDefault();
    }
    e.dataTransfer.dropEffect = 'move';
    return false;
}

function handleDragEnter(e) {
    if (this !== draggedItem && this.classList.contains('draggable-item')) {
        this.classList.add('drag-over');
    }
}

function handleDragLeave(e) {
    this.classList.remove('drag-over');
}

function handleDrop(e) {
    if (e.stopPropagation) {
        e.stopPropagation();
    }
    
    e.preventDefault();
    
    if (draggedItem !== this && this.classList.contains('draggable-item')) {
        // Get all items
        const allItems = [...document.querySelectorAll('.draggable-item')];
        const draggedIndex = allItems.indexOf(draggedItem);
        const targetIndex = allItems.indexOf(this);
        
        // Add swapping animation to affected items
        const itemsToAnimate = [];
        if (draggedIndex < targetIndex) {
            // Moving down - animate items between drag and target
            for (let i = draggedIndex + 1; i <= targetIndex; i++) {
                itemsToAnimate.push(allItems[i]);
            }
        } else {
            // Moving up - animate items between target and drag
            for (let i = targetIndex; i < draggedIndex; i++) {
                itemsToAnimate.push(allItems[i]);
            }
        }
        
        // Apply swap animation
        itemsToAnimate.forEach(item => {
            item.classList.add('swapping');
        });
        
        // Reorder in the DOM
        const answerList = document.getElementById('answerList');
        
        if (draggedIndex < targetIndex) {
            // Insert after target
            answerList.insertBefore(draggedItem, this.nextSibling);
        } else {
            // Insert before target
            answerList.insertBefore(draggedItem, this);
        }
        
        // Announce to screen readers
        const newPosition = [...document.querySelectorAll('.draggable-item')].indexOf(draggedItem) + 1;
        announceToScreenReader(`Moved ${draggedItem.textContent.trim()} to position ${newPosition}`);
        
        // Remove swap animation after it completes
        setTimeout(() => {
            itemsToAnimate.forEach(item => {
                item.classList.remove('swapping');
            });
        }, 400);
        
        // Clear any feedback from previous check
        allItems.forEach(item => {
            item.classList.remove('correct', 'incorrect');
        });
    }
    
    this.classList.remove('drag-over');
    return false;
}

function announceToScreenReader(message) {
    const announcement = document.getElementById('sr-announcement');
    announcement.textContent = message;
}

function checkAnswers() {
    const items = document.querySelectorAll('.draggable-item');
    let userAnswers = [];
    let correctCount = 0;
    let incorrectItems = [];

    // Collect user answers and check each position
    items.forEach((item, index) => {
        const answer = item.getAttribute('data-id');
        userAnswers.push(answer);
        
        // Check if correct
        if (answer === correctOrder[index]) {
            item.classList.add('correct');
            item.classList.remove('incorrect');
            item.setAttribute('aria-label', `${item.textContent.trim()} - Correct position`);
            correctCount++;
        } else {
            item.classList.add('incorrect');
            item.classList.remove('correct');
            item.setAttribute('aria-label', `${item.textContent.trim()} - Incorrect position`);
            incorrectItems.push(item.textContent.trim());
        }
    });

    // Display results
    if (correctCount === correctOrder.length) {
        showModal('Perfect! ðŸŽ‰', '<p>All items are correctly matched in the right order!</p>');
        announceToScreenReader('Perfect! All items are correctly matched in the right order!');
    } else {
        const percentage = Math.round((correctCount / correctOrder.length) * 100);
        let message = `<p>You got ${correctCount} out of ${correctOrder.length} correct (${percentage}%).</p>`;
        message += '<p>Items with green backgrounds are in the correct position, red backgrounds are incorrect.</p>';
        showModal('Results', message);
        
        const srMessage = `You got ${correctCount} out of ${correctOrder.length} correct. Incorrect items: ${incorrectItems.join(', ')}`;
        announceToScreenReader(srMessage);
    }
}

function showModal(title, message) {
    document.getElementById('modalTitle').textContent = title;
    document.getElementById('modalMessage').innerHTML = message;
    document.getElementById('resultsModal').classList.add('show');
}

function closeModal() {
    document.getElementById('resultsModal').classList.remove('show');
}

// Initialize on page load
initDragAndDrop();
</script>
</body>
</html>